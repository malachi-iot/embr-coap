#pragma once

#include <estd/cstdint.h>
#include "internal/header.h"
#include <new>

namespace embr { namespace coap {

#if FEATURE_MCCOAP_HEADER_VERSION == FEATURE_MCCOAP_HEADER_LEGACY
typedef internal::legacy::Header Header;
#elif FEATURE_MCCOAP_HEADER_VERSION == FEATURE_MCCOAP_HEADER_CXX_03
typedef internal::cxx_03::Header Header;
#else
typedef internal::cxx_11::Header Header;
#endif


// in regular conditions:
// * CON request always has some response
// * NON request may or may not have a response (only if server wants to communicate something back)
// * ACK request should never appear
// * RESET request
inline void process_request(Header input, Header* output)
{
    // We always want to echo back the Message ID
    output->copy_message_id(input);

    // copies TKL, Type and Ver
    // We always want to echo back TKL
    // We always overwrite or keep Type
    // We always expect Ver to be 1
    output->bytes[0] = input.bytes[0];

    // TODO: Handle case where Ver != 1

    // We don't touch Code, since later business logic needs
    // to figure that one out

    if(input.type() == Header::Confirmable)
    {
        // ACK is always presented on CON, even in piggyback scenarios
        output->type(Header::Acknowledgement);
    }
    else if(input.type() == Header::NonConfirmable)
    {
        // Keep the already-copied NON
        // NON need not respond but if one is explicitly calling
        // process_request, then we presume a response is desired
    }
    else
    {
        // ACK and RESET should not appear for a request
        ASSERT_ERROR(true, false, "Unexpected header type " << input.type());
    }
}


// TODO: Clean this up a bit + document
inline Header create_response(Header incoming, Header::Code code)
{
    Header output;

    process_request(incoming, &output);

    output.code(code);

    return output;
}


inline bool process_response(Header input, Header* output)
{
    switch(input.type())
    {
        case Header::Confirmable:
            // response (to response) required
            // this represents non-piggyback response (and maybe Observable update)
            // copies TKL, Type and Ver
            // We always want to echo back TKL
            // We always overwrite or keep Type
            // We always expect Ver to be 1
            output->bytes[0] = input.bytes[0];
            output->copy_message_id(input); // Echo back MID which is in this unusual case generated by server
            output->type(Header::Acknowledgement);
            return true;

        case Header::Acknowledgement:
            // No output needed when processing an Ack response
            return false;

        case Header::Reset:
            // A retry with different mid/token may be necessary here
            // won't categorize as output because it's more of a reinitiation of request
            return false;

        case Header::NonConfirmable:
            // Expected when we issued a NON request, but MAY appear from a CON
            // request too.  In either case, no response required
            return false;

        default:
            return false;
    }
}


inline const char* to_string(Header::Types type)
{
    switch(type)
    {
        case Header::Confirmable:       return "Confirmable";
        case Header::NonConfirmable:    return "NonConfirmable";
        case Header::Acknowledgement:   return "Acknowledgement";
        case Header::Reset:             return "Reset";
        default:                        return NULLPTR;
    }
}


#ifdef FEATURE_MCCOAP_IOSTREAM_NATIVE
inline std::ostream& operator <<(std::ostream& out, Header::Types type)
{
    out << to_string(type);
    return out;
}
#endif



}}
