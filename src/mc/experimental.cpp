//
// Created by Malachi Burke on 1/6/18.
//

#include "experimental.h"

namespace moducom { namespace coap { namespace experimental {


// in regular conditions:
// * CON request always has some response
// * NON request may or may not have a response (only if server wants to communicate something back)
// * ACK request should never appear
// * RESET request
void process_header_request(Header input, Header* output)
{
    if(input.type() == Header::Confirmable)
    {
        output->copy_message_id(input);
        output->type(Header::Acknowledgement);
        // piggbacked NOT processed here because whether piggyback or separate,
        // ACK is always presented on initial confirmable receipt
    }
    else if(input.type() == Header::NonConfirmable)
    {
        // A request may either be CON, NON or we the responder may elect
        // to just not respond at all
    }
    else
    {
        // ACK and RESET should not appear for a request
        ASSERT_ERROR(true, false, "Unexpected header type " << input.type());
    }
}

// input must be a CON message for this method
bool process_reset(Header input, Header* output)
{
    output->copy_message_id(input);
    output->type(Header::Reset);
    return true;
}

bool process_header_response(Header input, Header* output)
{
    switch(input.type())
    {
        case Header::Confirmable:
            // response (to response) required
            // this represents non-piggyback response (and maybe Observable update)
            output->copy_message_id(input); // Echo back MID which is in this unusual case generated by server
            output->type(Header::Acknowledgement);
            return true;

        case Header::Acknowledgement:
            // No output needed when processing an Ack response
            return false;

        case Header::Reset:
            // A retry with different mid/token may be necessary here
            // won't categorize as output because it's more of a reinitiation of request
            return false;

        case Header::NonConfirmable:
            // Expected when we issued a NON request, but MAY appear from a CON
            // request too.  In either case, no response required
            return false;
    }

}


const pipeline::MemoryChunk v2::ManagedBuffer::current() const
{
    chunk_t temp((uint8_t*)chunk.data(current_pos), chunk.length() - current_pos);

    return temp;
}

const pipeline::MemoryChunk::readonly_t v2::ManagedBuffer::current_ro(boundary_t boundary) const
{
    if(boundary == 0)
    {
        ro_chunk_t temp((uint8_t*) chunk.data(current_pos), chunk.length() - current_pos);

        return temp;
    }
    else
    {
        const BoundaryDescriptor* bd = &boundaries[current_boundary];
        size_t temp_length;
        int i = current_boundary;

        for(; i < boundary_count && bd->boundary != boundary; i++, bd++)
        {
        }

        if(i == boundary_count)
        {
            // got to end and didn't find boundary, so use whole length
            temp_length = chunk.length();
        }
        else
        {
            // found the boundary
            temp_length = bd->pos;
        }

        temp_length -= current_pos;

        ro_chunk_t temp((uint8_t*) chunk.data(current_pos), temp_length);

        return temp;
    }
}


bool v2::ManagedBuffer::next()
{
    // this is for read mode only
    const BoundaryDescriptor& bd = boundaries[current_boundary];

    current_pos += bd.pos;

    if(current_boundary < boundary_count)
    {
        current_boundary++;
    }
    /*
    {
        BoundaryDescriptor& bd = boundaries[current_boundary];
    } */

    return true;
}


bool v2::ManagedBuffer::reset(bool reset_boundaries)
{
    current_pos = 0;
    current_boundary = 0;
    return true;
}


bool v2::ManagedBuffer::boundary(boundary_t boundary, size_t position)
{
    BoundaryDescriptor& bd = boundaries[boundary_count++];

    bd.boundary = boundary;
    bd.pos = current_pos + position;

    current_pos += position;
    return true;
}


v2::ManagedBuffer::ManagedBuffer() :
        boundary_count(0),
        current_boundary(0),
        current_pos(0)
{

}

}}}